name: Pull Request

on:
  pull_request:
    types: [opened, synchronize, reopened]

jobs:
  lint:
    name: Lintowanie kodu
    runs-on: ubuntu-latest
    env:
      RUBOCOP_CACHE_ROOT: tmp/rubocop
      ERB_LINT_CACHE_ROOT: tmp/erb_lint
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Prepare RuboCop cache
        uses: actions/cache@v4
        env:
          DEPENDENCIES_HASH: ${{ hashFiles('.ruby-version', '**/.rubocop.yml', '**/.rubocop_todo.yml', 'Gemfile.lock') }}
        with:
          path: ${{ env.RUBOCOP_CACHE_ROOT }}
          key: rubocop-${{ runner.os }}-${{ env.DEPENDENCIES_HASH }}-${{ github.ref_name == github.event.repository.default_branch && github.run_id || 'default' }}
          restore-keys: |
            rubocop-${{ runner.os }}-${{ env.DEPENDENCIES_HASH }}-

      - name: Prepare ERB Lint cache
        uses: actions/cache@v4
        env:
          DEPENDENCIES_HASH: ${{ hashFiles('.ruby-version', '.erb_lint.yml', 'Gemfile.lock') }}
        with:
          path: ${{ env.ERB_LINT_CACHE_ROOT }}
          key: erb-lint-${{ runner.os }}-${{ env.DEPENDENCIES_HASH }}-${{ github.ref_name == github.event.repository.default_branch && github.run_id || 'default' }}
          restore-keys: |
            erb-lint-${{ runner.os }}-${{ env.DEPENDENCIES_HASH }}-

      - name: Lint code for consistent style
        run: bin/rubocop -f github

      - name: Lint ERB templates
        run: bundle exec erb_lint --lint-all --format compact --cache --cache-dir ${{ env.ERB_LINT_CACHE_ROOT }}

  unit-test:
    name: Testy jednostkowe
    runs-on: ubuntu-latest
    needs: lint

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: --health-cmd="pg_isready" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      - name: Install packages
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y libpq-dev

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run unit tests with coverage
        env:
          RAILS_ENV: test
          DATABASE_URL: postgres://postgres:postgres@localhost:5432
          COVERAGE: true
        run: |
          bin/rails db:test:prepare
          bundle exec rspec --exclude-pattern "spec/system/**/*_spec.rb" --format documentation

      - name: Upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: unit-coverage
          path: coverage/
          retention-days: 7

  e2e-test:
    name: Testy E2E
    runs-on: ubuntu-latest
    needs: lint

    services:
      postgres:
        image: postgres
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
        ports:
          - 5432:5432
        options: --health-cmd="pg_isready" --health-interval=10s --health-timeout=5s --health-retries=3

    steps:
      - name: Install packages
        run: sudo apt-get update && sudo apt-get install --no-install-recommends -y libpq-dev

      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true

      - name: Run E2E tests with coverage
        env:
          RAILS_ENV: test
          DATABASE_URL: postgres://postgres:postgres@localhost:5432
          COVERAGE: true
        run: |
          bin/rails db:test:prepare
          bundle exec rspec spec/system --format documentation

      - name: Upload E2E test coverage
        uses: actions/upload-artifact@v4
        with:
          name: e2e-coverage
          path: coverage/
          retention-days: 7

      - name: Keep screenshots from failed system tests
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: screenshots
          path: ${{ github.workspace }}/tmp/screenshots
          if-no-files-found: ignore

  status-comment:
    name: Komentarz ze statusem
    runs-on: ubuntu-latest
    needs: [lint, unit-test, e2e-test]
    if: always() && github.event_name == 'pull_request'
    permissions:
      pull-requests: write
      contents: read
    
    steps:
      - name: Download unit coverage
        uses: actions/download-artifact@v4
        with:
          name: unit-coverage
          path: coverage-unit
        continue-on-error: true

      - name: Download E2E coverage
        uses: actions/download-artifact@v4
        with:
          name: e2e-coverage
          path: coverage-e2e
        continue-on-error: true

      - name: Parse coverage results
        id: coverage
        run: |
          UNIT_COVERAGE="N/A"
          E2E_COVERAGE="N/A"
          
          # SimpleCov-json generates coverage.json
          if [ -f "coverage-unit/coverage.json" ]; then
            UNIT_COVERAGE=$(grep -o '"covered_percent":[0-9.]*' coverage-unit/coverage.json | head -1 | cut -d':' -f2 || echo "N/A")
          fi
          
          if [ -f "coverage-e2e/coverage.json" ]; then
            E2E_COVERAGE=$(grep -o '"covered_percent":[0-9.]*' coverage-e2e/coverage.json | head -1 | cut -d':' -f2 || echo "N/A")
          fi
          
          echo "unit=$UNIT_COVERAGE" >> $GITHUB_OUTPUT
          echo "e2e=$E2E_COVERAGE" >> $GITHUB_OUTPUT

      - name: Determine overall status
        id: status
        run: |
          LINT_STATUS="${{ needs.lint.result }}"
          UNIT_STATUS="${{ needs.unit-test.result }}"
          E2E_STATUS="${{ needs.e2e-test.result }}"
          
          if [ "$LINT_STATUS" == "success" ] && [ "$UNIT_STATUS" == "success" ] && [ "$E2E_STATUS" == "success" ]; then
            echo "result=‚úÖ Wszystkie testy przesz≈Çy pomy≈õlnie!" >> $GITHUB_OUTPUT
            echo "color=28a745" >> $GITHUB_OUTPUT
          else
            echo "result=‚ùå Niekt√≥re testy nie powiod≈Çy siƒô" >> $GITHUB_OUTPUT
            echo "color=d73a49" >> $GITHUB_OUTPUT
          fi
          
          echo "lint=$LINT_STATUS" >> $GITHUB_OUTPUT
          echo "unit=$UNIT_STATUS" >> $GITHUB_OUTPUT
          echo "e2e=$E2E_STATUS" >> $GITHUB_OUTPUT

      - name: Create or update PR comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const lintStatus = '${{ steps.status.outputs.lint }}';
            const unitStatus = '${{ steps.status.outputs.unit }}';
            const e2eStatus = '${{ steps.status.outputs.e2e }}';
            const unitCoverage = '${{ steps.coverage.outputs.unit }}';
            const e2eCoverage = '${{ steps.coverage.outputs.e2e }}';
            
            const statusIcon = (status) => {
              if (status === 'success') return '‚úÖ';
              if (status === 'failure') return '‚ùå';
              if (status === 'cancelled') return 'üö´';
              return '‚è≠Ô∏è';
            };
            
            const formatCoverage = (coverage) => {
              if (coverage === 'N/A') return 'N/A';
              return `${parseFloat(coverage).toFixed(2)}%`;
            };
            
            const body = `## üîç Status Test√≥w Pull Request
            
            | Etap | Status | Szczeg√≥≈Çy |
            |------|--------|-----------|
            | Lintowanie | ${statusIcon(lintStatus)} ${lintStatus} | Sprawdzanie stylu kodu |
            | Testy jednostkowe | ${statusIcon(unitStatus)} ${unitStatus} | Coverage: ${formatCoverage(unitCoverage)} |
            | Testy E2E | ${statusIcon(e2eStatus)} ${e2eStatus} | Coverage: ${formatCoverage(e2eCoverage)} |
            
            ### ${{ steps.status.outputs.result }}
            
            ---
            *Automatycznie wygenerowane przez GitHub Actions* ‚Ä¢ [Zobacz szczeg√≥≈Çy](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})`;
            
            // Find existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('Status Test√≥w Pull Request')
            );
            
            if (botComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
